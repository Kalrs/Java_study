### 接口语法
```java
  interface 接口名{
  //静态常量，抽象方法
  }
```
### 接口特点
- 接口只存放静态常量和抽象方法
- java接口是对功能的扩展
- 通过实现接口，java类可以实现多实现
- 一个类可以同时继承(extends)一个父类并且实现(implements)多个接口
- 接口与接口之间可以通过使用extends来产生继承关系
### 接口与抽象了区别
- 抽象类和具体实现类之间是一种继承关系，也就是说如果采用抽象类的方式，则父类和子类在概念上应该是相同的
- 接口和实现类在概念上不要求相同，接口只是抽取相互之间没有关系的类的共同特征，而不去关注类之间的关系，它可以使没有层次关系的类具有相同的行为
- 首相类是对一组具有相同属性和行为的逻辑上有关系的事物的一种抽象，而接口则是对一组具有相同属性和行为的逻辑上下不想关的事物的一种抽象
- 对于接口和抽象可u的选择，反映处设计人员看待问题的不同角度。抽象类用于一组相关的事物，表时“is-a”的关系；而接口用于一组不相关的事物，表示“like-a”
### 实例
```java
  package my;

public class InterdaceDemo {
	public static void main(String [] args) {
		//System.out.println(IAbility.number);
		Person1 p = new Person1();
		Child c=new Child();
		Dog1 d =new Dog1();
		p.feed(c);
		p.feed(d);
	}
}
interface IAbility{
	//放公有的静态方法和抽象方法
	//public static final int number=1;
	//int number=1  默认加上public static final
	//public abstract void show();
	//void show(); 默认加上public abstract
	//接口引用变量可以引用实现类对象
	public abstract  void eating();
}
class Child implements IAbility{
	public void eating(){
		System.out.println("吃饭");
	}
}
class Dog1 implements IAbility{
	public void eating(){
		System.out.println("啃骨头");
	}
}

class Person1{
//	public void feed(Child child) {
//		child.eat();
//	}
//	public void feed(Dog1 dog) {
//		dog.eat();
//	}
	public void feed (IAbility a) {
		a.eating();
	}
	
}
```
### 面向接口编程
- 开发系统时，主机构架使用接口，接口构成系统的骨架
- 这样就可以通过更换接口的实现类来更换系统
### 实例
```java
	package my;

public class PrinterDemo {
		public	static void main(String [] args) {
			
			//ColorPrinter cp =new ColorPrinter("惠普");
			BlackPrinter bp =new BlackPrinter("戴尔");
			School s=new School();
			s.Setp(bp);
			Teacher3 t=new Teacher3("张三",12);
			s.Print(t);
		}
}
abstract class Printer{
	private String brand;
	public Printer(String brand) {
		this.brand=brand;
	}
	public String getBrand() {
		return brand;
	}
	public abstract void print(String content);
	
}
interface IInfo{
	String detail();
}
// 开闭原则:对修改是封闭的，对扩展是开放的.不要违反开闭原则
// 可以用多态解决问题。父类的引用变量引用其子类对象
class School  implements IInfo{
	/*private ColorPrinter cp=null;
	private BlackPrinter bp=null;
	public void Setcp(ColorPrinter cp) {
		this.cp=cp;
	}
	public void Setbp(BlackPrinter bp) {
		this.bp=bp;
	}
	public void Print(String content) {
		//交给中心所安装的彩色打印机来打印
		bp.Print(content);
	}*/
	private Printer p= null;
	//拿父类的引用变量作为参数，好处是可以接受任意子类对象
	public void  Setp(Printer p) {
		this.p=p;
	}
	public void Print(IInfo info) {
		//交给中心所安装的彩色打印机来打印
		p.print(info.detail());
	}
	public String detail() {
		return "我是超级w无敌李大帅";
	}
}
class ColorPrinter extends Printer{
	public ColorPrinter(String brand) {
		super(brand);
	}
	public void print(String brand) {
		System.out.println(getBrand()+"彩色打印机:"+brand);
	}
}
class BlackPrinter extends Printer{
	public BlackPrinter(String brand) {
		super(brand);
	}
	public void print(String brand) {
		System.out.println(getBrand()+"黑白打印机"+brand);
	}
}
class Teacher3 implements IInfo{
	private String name;
	private int age;
	public Teacher3 (String name,int age) {
		this.name=name;
		this.age=age; 
	}	
	public String detail() {
		return "我是超级无敌李大叔"+name+age+"岁";
	}
}

```
### 简单工厂模式
- 定义:专门定义一个类来负责创建其它类的实例，被创建的实例通常是具有共同的父类或接口
- 意图:提供一个类，有它负责根据一定的条件创建某一具体类的实例
### 实例
```java
	package my;

public class FactoryDemo {
	public static void main(String [] aegs) {
		IFruit	fruit=Factory.getFruit("苹果");
		if(fruit!=null) {
			System.out.println(fruit.get());
		}else {
			System.out.println("sorry");
		}
	}
}
interface IFruit{
	public String get();
}
class Factory{
	public static IFruit getFruit(String name) {
		if(name.equals("苹果")) {
			return new Apple();
		}else if(name.equals("橘子")) {
			return new Orange();
		}else {
			return null;
		}
	}
}
class Apple implements  IFruit{
	public String get() {
		return "采摘苹果";
	}
}
class Orange implements  IFruit{
	public String get(){
		return "采摘橘子";
	}
}

```
